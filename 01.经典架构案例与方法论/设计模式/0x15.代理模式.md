# 代理模式

## 0x01.定义与类型

- 定义：为其他对象提供一种代理，以控制对这个对象的访问。
- 代理对象在客户端和目标对象之间起到中介的作用。
- 类型：结构型

## 0x02.适用场景

- 保护目标对象
- 增强目标对象

## 0x03.优点

- 代理模式能将代理对象与真实被调用的目标对象分离
- 一定程度上降低了系统的耦合度，扩展性好
- 保护目标对象
- 增强目标对象

## 0x04.缺点

- 代理模式会造成系统设计中类的数据增加
- 在客户端和目标对象增加一个代理对象，会造成请求处理速度缓慢
- 增加了系统的复杂度

## 0x05.扩展

- 静态代理：通过在代码中显示定义了一个业务实现类的代理，在代理类中实现了同名的被代理类的方法，通过调用代理类的方法，实现对被代理类方法的增强。
- 动态代理：通过接口中的方法名在动态生成的代理中动态调用实现类中的同名方法。一定是接口
- CGLib代理：通过继承，注意final。生成的代理类是业务类的子类，重写父类的方法实现代理。

## 0x06.Spring代理选择

- 当Bean有实现接口时，Spring就会用JDK的动态代理
- 当Bean没有实现接口时，Spring适用CGLib
- 可以强制适用Cglib，在spring配置中加入<aop:aspectj-autoproxy proxy-target-class="true"/>
- 查看spring core官方文档

## 0x07.代理速度的扩展

- CGLib -->ASM字节码生成
- JDK动态代理
- jdk比cglib快20%左右

## 0x08.相关设计模式

- 代理模式和装饰者模式
    - 装饰者模式是为对象添加行为
    - 代理模式是控制对象的访问，增强目标对象
- 代理模式和适配器模式
    - 适配器模式考虑对象的接口
    - 代理不能代理接口